/*
* @Author: Zhang Guohua
* @Date:   2018-11-27 14:28:15
* @Last Modified by:   zgh
* @Last Modified time: 2018-12-24 13:10:57
* @Description: create by zgh
* @GitHub: Savour Humor
*/
# 函数的扩展

## 内容
1. 参数默认值： 使用 let 定义变量，之前是 var 定义变量。如果不为 undefined，则使用传入的值。 即局部变量。
    1. 那么考虑使用时，只能省略后方的参数了，因为前方的参数无法省略。
    2. length失真， length 属性指没有指定默认值的参数。 如果默认值参数不是 尾参数，那么后面的参数将不再计入其长度。
    3. 默认值实际上是一个独立的作用域，高于函数体内，小于函数体外。当然也存在暂时性死区。

2. 参数与解构赋值默认值结合: 
    1. 函数的参数必须符合解构的格式。
    2. 可以设置默认值为 {};

3. rest参数: 获取指定参数名外多余参数。 ...arr, 
    1. 在该参数后不能再有参数，否则将报错。
    2. 该参数不计入 length 属性。因为有默认值 []。
    
4. 严格模式: use strict; ES5 开始 函数内部可以设置严格模式。
    1. 只要参数使用: 默认值，解构赋值，rest模式，内部就不能显示设定为 严格模式。原因为严格模式适用于函数体，参数。在执行参数时，无法知道是否使用了严格模式。
    2. 解决方法方法： 设置全局严格模式，或者通过立即执行函数设置，即上一级不使用上述参数的函数中设置严格模式。原理同第一种。

5. 箭头函数: 作用清晰简洁。下面说说注意事项：
    1. 参数使用 () 包括，一个也一样。代码规范。
    2. 同函数一样，所以可以使用函数的扩展，默认值，解构赋值，rest 参数等。
    3. 函数体内的 this 对象，不再是谁调用就是谁，而是定义时，所在的上下文对象。
    4. 不可以当做构造函数。不可以使用 arguments。不可以使用 yield，所以不能作为 Generator 函数。
    5. 对象内部定义方法，使用箭头函数会使 this 指向 定义对象的上下文。

6. 函数绑定运算符: :: 。左边是一个对象，右边是一个函数。将对象作为 this 绑定在函数上。
    1. 左边为空，即不绑定新的 this。
    2. 提案，目前并不可用。
    
7. 尾调用优化(tail call): 函数调用会在内存形成一个调用记录，又称为调用帧。保存调用位置和内部变量信息。所有的调用记录，会形成一个调用栈。
    1. A在尾部调用B, 那么 A的调用帧会在 B 结束后再消失。而如果在尾部调用，利用提前消除调用帧，从而节省内存。
    2. 理解，但是不感觉到作用，因为函数内部调用，一般都要用到函数内部的变量。
    3. 如果函数参数，不被作为A调用帧的内容，那可能在一定情况下是有优势的。
    4. 尾递归： 递归非常消耗内存，需要同时保存多个调用帧，而尾递归则始终只使用一个调用帧。看示例内容（）。
    5. 改写函数为尾递归，需要修改内部变量为函数的参数。通过默认参数类优化参数形式。
    6. 尾部调用优化，只在严格模式下启用。因为正常模式中，函数内部有两个参数跟踪调用栈，arguments, caller。尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。
    7. Ployfill： 通过蹦床函数，函数返回函数，

8. 尾逗号： ES2017 允许最后一个参数有尾逗号。
    1. 一方面与数组，对象结尾保持一致。
    2. 另一方面，修改代码不显得冗余。


## 注意事项
1. 使用箭头函数时, 返回一个对象，需要用括号包括。否则返回 undefined.

## 思想方法
1. 柯里化： 函数式编程中，将多参数的函数转换为单参数的形式。

## 之前内容回顾
1. this 指向调用自己的对象。
2. 绑定 this 对象的方法:
    1. call:
    2. apply:
    3. bind: 