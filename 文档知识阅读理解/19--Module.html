<!--
* @Author: Zhang Guohua
* @Date:   2018-06-21 14:01:52
* @Last Modified by:   zgh
* @Last Modified time: 2019-01-29 10:07:34
* @Description: create by zgh
* @GitHub: Savour Humor
-->
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>module语法</title>

</head>
<body>
	

	<script type="text/javascript">
		//////
		//  module:
		//  	引入模块体系，解决拆分拼装。像Ruby的require, Python的import,CSS的@import.
		//  	社区方案： CommonJS(服务器), AMD(浏览器), CMD.
		//  	Module可以取代上述方案，实现简单，通用。
		//  	
		//  思想：
		//  	尽量静态化，使得在编译时确定模块的依赖关系，以及输入输出变量。
		//  	社区的方案是在运行时确定，如CommonJS模块就是对象，输入时必须查找对象属性。
		//  	
		//  优势：
		//  	1. 实现静态分析。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。
		//  	2. 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。
		//  	3. 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
		//  	4. 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
		//  
		//  定义： 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。
		//  
		//  
		//  练习： 
		//  	放在idea中了。
		//////
		///
		
		// CommonJS方法
			// let { s, b, a} = require('fs'); => 等同于
			// let _fs = require('fs');
			// let s = _fs.s;
			// let b = _fs.b;
			// let a = _fs.a;
		// 只有运行时才能得到这个对象，无法做静态优化。
		// 
		// ES6的模块不是对象，而是通过export命令显示的指定输出代码，再通过import命令输入。
			// import { s, a } from 'f';
		// 这个是从f加载两个模块，其他模块不加载。成为编译时加载或静态加载。导致了无法引用ES6模块本身，因为他不是对象。
		// 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。
		// 
		
		// 格式：默认严格模式。
		// 	在ES6的模块中，顶层this指向undefined.即不应该在顶层中使用this.
		// 	
		// 	
		// 	
		// 	命令： 	export 模块对外接口， 输出一组变量，函数，类。可以用as重命名。同一变量可以用不同名字输出两次。export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。动态绑定值，可以取到模块内部值的实时的值（这点与CommonJS完全不同，CommonJS输出的是缓存值不动态更新）。export可以出现在模块任何位置，只要在顶层就可以。块级作用域会报错(import也一样。是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。)。
		// 	
		// 	
		// 			import 输入其他模块提供的功能; 
		// 			大括号的变量名必须与被导入的模块定义的对外接口名称相同。想要重命名，同样用as进行。
		// 			import输入的变量都是只读的，本质是输入接口，不允许在加载模块的脚本里改写接口,可以改写相关属性，其他模块也将会收到改写后的值，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性
		// 			。from 指定文件的相对/绝对位置js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。
		// 			注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。需要在js上加入type=module。
		// 			import语句会执行所加载的模块。如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
		// 			从同一模块，用两个语句加载两个接口，等同于一个语句直接加载两个模块。因为import是单例模式(singleton);
		// 			
		// 			
		// 	模块的整体加载：
		// 		使用*指定一个对象，所有输出值都加载在这个对象上面。
		// 	
		// 	
		// 	export default
		// 		用户不需要知道这个模块输出那些属性和方法，模块指定默认输出。一个模块只能有一个默认输出。所以import不需要加{}，因为只能对应唯一一个exportdefault。
		// 		本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。
		// 		export default其实是输出一个default 变量，后面不能跟变量声明语句。可以直接将变量或值卸载default后面。
		// 		同样可以用来输出类。
		// 		
		// 	export import 复合写法：
		// 		如果再一个模块中先输入后输出同一个模块，import和export可以写在一起。写成一行时，相当于转发接口，导致当前模块不能使用foo, bar;
		// 		export {bar, foo} from 'my_module'; 相当于：
		// 		import {bar, foo} from 'my_module'; export {bar, foo};
		// 		
		//  模块的继承
		//  	export * 会忽略 default 方法。
		//  	
		//  跨模块常量：
		//  	若一个值要被多个模块共享，则导出变量属性。可以建立一个专门保存静态变量的模块。
		//  	把各种不同的模块写在一个文件中，访问时只需访问一个即可。
		//  	
		//  import()
		//  	import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行.这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。
		//  	提案建议引入import()完成动态加载。上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。import()返回一个 Promise 对象。import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。
		// 		适用场合：
		// 			按需加载。动态的模块路径。
		// 		注意点：
		// 			import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。如果模块有default输出接口，可以用参数直接获得。import()也可以写在async中。
		// 
		// 		
				
	</script>
</body>
</html>